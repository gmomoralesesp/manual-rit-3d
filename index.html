<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Manual 3D RIT - Final Corregido</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Roboto', sans-serif; background: #f0f2f5; color: #333; overflow: hidden; }
        #container { width: 100vw; height: 100vh; }
        
        /* Panel Lateral */
        #side-panel {
            position: absolute; top: 20px; left: 20px; width: 380px;
            background: linear-gradient(145deg, rgba(20, 20, 35, 0.95), rgba(30, 30, 50, 0.92));
            padding: 0; border-radius: 16px;
            border: 1px solid rgba(255, 77, 0, 0.2);
            z-index: 10; max-height: calc(100vh - 40px); overflow: hidden;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2), 0 0 60px rgba(255, 77, 0, 0.05);
            backdrop-filter: blur(10px);
            color: white;
        }

        .panel-header {
            background: linear-gradient(90deg, #ff4d00, #ff6a00);
            padding: 20px 25px;
            position: relative;
            overflow: hidden;
            color: white;
        }
        .panel-header::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg fill='%23ffffff' fill-opacity='0.1'%3E%3Cpath d='M36 34v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zm0-30V0h-2v4h-4v2h4v4h2V6h4V4h-4zM6 34v-4H4v4H0v2h4v4h2v-4h4v-2H6zM6 4V0H4v4H0v2h4v4h2V6h4V4H6z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E");
            opacity: 0.3;
        }
        .panel-header h1 {
            font-size: 1.3rem; font-weight: 700; margin: 0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            position: relative; z-index: 1;
        }
        .panel-header .subtitle {
            font-size: 0.8rem; opacity: 0.9; margin-top: 5px;
            position: relative; z-index: 1;
        }

        .panel-content {
            padding: 15px 20px 20px;
            max-height: calc(100vh - 160px);
            overflow-y: auto;
        }
        .panel-content::-webkit-scrollbar { width: 6px; }
        .panel-content::-webkit-scrollbar-track { background: rgba(255,255,255,0.05); }
        .panel-content::-webkit-scrollbar-thumb { background: #ff4d00; border-radius: 3px; }

        .instruccion {
            font-size: 0.85rem; color: #aaa; margin-bottom: 15px;
            padding: 10px 15px;
            background: rgba(255, 77, 0, 0.05);
            border-radius: 8px;
            border-left: 3px solid #ff4d00;
        }

        .section-title {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: #888;
            margin: 20px 0 10px;
            padding-left: 5px;
        }

        .rit-item {
            display: flex; align-items: center; padding: 12px 15px; margin-bottom: 8px;
            background: linear-gradient(90deg, rgba(40, 40, 60, 0.6), rgba(50, 50, 70, 0.4));
            border-radius: 10px; cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: 1px solid transparent;
            position: relative;
            overflow: hidden;
        }
        .rit-item::before {
            content: '';
            position: absolute;
            top: 0; left: -100%; width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,77,0,0.1), transparent);
            transition: left 0.5s;
        }
        .rit-item:hover::before { left: 100%; }
        .rit-item:hover {
            background: linear-gradient(90deg, rgba(60, 60, 90, 0.8), rgba(70, 70, 100, 0.6));
            transform: translateX(8px);
            border-color: rgba(255, 77, 0, 0.3);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
        }
        .rit-item.active {
            background: linear-gradient(90deg, rgba(255, 77, 0, 0.2), rgba(255, 77, 0, 0.05));
            border-color: #ff4d00;
            box-shadow: 0 0 30px rgba(255, 77, 0, 0.2), inset 0 0 20px rgba(255, 77, 0, 0.05);
        }
        
        .number-badge {
            background: linear-gradient(135deg, #ff4d00, #ff6a00);
            color: white; min-width: 32px; height: 32px;
            border-radius: 8px; display: flex; align-items: center; justify-content: center;
            font-weight: 700; margin-right: 15px; font-size: 0.85rem;
            box-shadow: 0 3px 10px rgba(255, 77, 0, 0.4);
            flex-shrink: 0;
        }
        .rit-item.active .number-badge {
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0%, 100% { box-shadow: 0 3px 10px rgba(255, 77, 0, 0.4); }
            50% { box-shadow: 0 3px 20px rgba(255, 77, 0, 0.8); }
        }

        .text-content { flex: 1; }
        .text-content b {
            display: block; font-size: 0.9rem; color: #4cc9f0;
            margin-bottom: 3px; font-weight: 500;
        }
        .rit-item.active .text-content b { color: #fff; }
        .text-content span { font-size: 0.75rem; color: #bbb; line-height: 1.4; }

        .item-icon {
            width: 24px; height: 24px; margin-left: 10px;
            opacity: 0; transition: all 0.3s;
        }
        .rit-item:hover .item-icon, .rit-item.active .item-icon {
            opacity: 1;
        }

        #legend {
            position: absolute; bottom: 20px; right: 20px;
            background: linear-gradient(145deg, rgba(20, 20, 35, 0.9), rgba(30, 30, 50, 0.85));
            padding: 20px; border-radius: 12px; font-size: 0.8rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            color: white;
        }
        #legend b {
            color: #ff4d00; display: block; margin-bottom: 12px;
            font-size: 0.75rem; letter-spacing: 1px;
        }
        .legend-item {
            display: flex; align-items: center; margin-bottom: 8px;
        }
        .color-dot {
            width: 14px; height: 14px; border-radius: 4px; margin-right: 10px;
            box-shadow: 0 0 5px currentColor;
        }

        /* Navigation Controls */
        #nav-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            background: linear-gradient(145deg, rgba(255, 255, 255, 0.95), rgba(240, 240, 250, 0.9));
            padding: 15px 20px;
            border-radius: 16px;
            border: 1px solid rgba(0, 0, 0, 0.05);
            backdrop-filter: blur(10px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }

        .nav-group {
            display: flex;
            gap: 5px;
            padding: 0 10px;
            border-right: 1px solid rgba(0,0,0,0.1);
        }
        .nav-group:last-child {
            border-right: none;
        }
        .nav-group-label {
            font-size: 0.65rem;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 5px;
            text-align: center;
        }

        .nav-btn {
            width: 44px;
            height: 44px;
            border: 1px solid rgba(255, 77, 0, 0.2);
            background: white;
            color: #ff4d00;
            border-radius: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            font-size: 1.2rem;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        .nav-btn:hover {
            background: #fff5f0;
            transform: scale(1.05);
            box-shadow: 0 4px 10px rgba(255, 77, 0, 0.2);
        }
        .nav-btn:active {
            transform: scale(0.95);
        }
        .nav-btn svg {
            width: 22px;
            height: 22px;
            fill: currentColor;
        }

        .nav-btn.reset-btn {
            background: #f0fbff;
            border-color: rgba(0, 180, 216, 0.3);
            color: #00b4d8;
        }
        .nav-btn.reset-btn:hover {
            background: #e0f7fa;
            box-shadow: 0 4px 10px rgba(0, 180, 216, 0.2);
        }

        /* View presets */
        #view-presets {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .preset-btn {
            padding: 10px 16px;
            background: linear-gradient(145deg, rgba(20, 20, 35, 0.9), rgba(30, 30, 50, 0.85));
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #ccc;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }
        .preset-btn:hover {
            background: rgba(255, 77, 0, 0.1);
            border-color: #ff4d00;
            color: #fff;
        }
        .preset-btn svg {
            width: 16px;
            height: 16px;
        }

        #loading {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: #f0f2f5;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            z-index: 1000;
            transition: opacity 0.5s;
        }
        #loading.hidden { opacity: 0; pointer-events: none; }
        .loader {
            width: 60px; height: 60px;
            border: 3px solid rgba(255, 77, 0, 0.2);
            border-top-color: #ff4d00;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        #loading p { margin-top: 20px; color: #555; font-weight: 500; }

        #tooltip {
            position: absolute;
            background: linear-gradient(145deg, rgba(255, 77, 0, 0.95), rgba(255, 100, 0, 0.9));
            color: white;
            padding: 8px 15px;
            border-radius: 8px;
            font-size: 0.8rem;
            font-weight: 500;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 100;
            box-shadow: 0 5px 20px rgba(0,0,0,0.2);
        }
        #tooltip.visible { opacity: 1; }

        /* Info panel for selected item */
        #info-panel {
            position: absolute;
            top: 50%;
            right: 220px;
            transform: translateY(-50%);
            background: linear-gradient(145deg, rgba(255, 255, 255, 0.95), rgba(245, 245, 250, 0.92));
            padding: 20px 25px;
            border-radius: 16px;
            border: 2px solid #ff4d00;
            max-width: 300px;
            opacity: 0;
            pointer-events: none;
            transition: all 0.3s;
            box-shadow: 0 10px 40px rgba(0,0,0,0.15);
            color: #333;
        }
        #info-panel.visible {
            opacity: 1;
            pointer-events: auto;
        }
        #info-panel .info-number {
            position: absolute;
            top: -15px;
            left: 20px;
            background: linear-gradient(135deg, #ff4d00, #ff6a00);
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.2rem;
            box-shadow: 0 4px 15px rgba(255, 77, 0, 0.4);
        }
        #info-panel .info-title {
            color: #333;
            font-size: 1.1rem;
            font-weight: 700;
            margin-top: 10px;
            margin-bottom: 10px;
        }
        #info-panel .info-desc {
            color: #666;
            font-size: 0.85rem;
            line-height: 1.5;
        }
        #info-panel .info-close {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            color: #999;
            cursor: pointer;
            font-size: 1.2rem;
            transition: color 0.2s;
        }
        #info-panel .info-close:hover {
            color: #ff4d00;
        }

        /* Toggle labels button */
        #toggle-labels {
            position: absolute;
            top: 20px;
            left: 420px;
            padding: 10px 16px;
            background: linear-gradient(145deg, rgba(20, 20, 35, 0.9), rgba(30, 30, 50, 0.85));
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #ccc;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }
        #toggle-labels:hover {
            background: rgba(255, 77, 0, 0.1);
            border-color: #ff4d00;
            color: #fff;
        }
        #toggle-labels.active {
            background: rgba(255, 77, 0, 0.2);
            border-color: #ff4d00;
            color: #fff;
        }
    </style>
</head>
<body>

<div id="loading">
    <div class="loader"></div>
    <p>Cargando modelo 3D (Final Revisado)...</p>
</div>

<div id="side-panel">
    <div class="panel-header">
        <h1>üè¢ Estructura RIT Interactiva</h1>
        <div class="subtitle">Ley de Ductos 20.808 - Chile</div>
    </div>
    <div class="panel-content">
        <div class="instruccion">
            üñ±Ô∏è Haz clic en un componente para inspeccionarlo. Usa los controles de navegaci√≥n o el mouse.
        </div>
        <div class="section-title">Componentes de la Red</div>
        <div id="menu-items"></div>
    </div>
</div>

<button id="toggle-labels">
    <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M7 7h10v10M7 17L17 7"/>
    </svg>
    Mostrar Etiquetas
</button>

<div id="view-presets">
    <button class="preset-btn" data-view="front">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <rect x="3" y="3" width="18" height="18" rx="2"/>
        </svg>
        Vista Frontal
    </button>
    <button class="preset-btn" data-view="side">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M12 3v18M3 12h18"/>
        </svg>
        Vista Lateral
    </button>
    <button class="preset-btn" data-view="top">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="12" cy="12" r="9"/>
            <circle cx="12" cy="12" r="3"/>
        </svg>
        Vista Superior
    </button>
    <button class="preset-btn" data-view="iso">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/>
        </svg>
        Vista Isom√©trica
    </button>
</div>

<div id="nav-controls">
    <div class="nav-group">
        <div style="display: flex; flex-direction: column; align-items: center;">
            <div class="nav-group-label">Rotar</div>
            <div style="display: flex; gap: 5px;">
                <button class="nav-btn" data-action="rotate-left" title="Rotar Izquierda">
                    <svg viewBox="0 0 24 24"><path d="M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8z"/></svg>
                </button>
                <button class="nav-btn" data-action="rotate-right" title="Rotar Derecha">
                    <svg viewBox="0 0 24 24"><path d="M11.5 8c2.65 0 5.05.99 6.9 2.6L22 7v9h-9l3.62-3.62c-1.39-1.16-3.16-1.88-5.12-1.88-3.54 0-6.55 2.31-7.6 5.5l-2.37-.78C2.92 11.03 6.85 8 11.5 8z"/></svg>
                </button>
                <button class="nav-btn" data-action="rotate-up" title="Rotar Arriba">
                    <svg viewBox="0 0 24 24"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"/></svg>
                </button>
                <button class="nav-btn" data-action="rotate-down" title="Rotar Abajo">
                    <svg viewBox="0 0 24 24"><path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6z"/></svg>
                </button>
            </div>
        </div>
    </div>
    <div class="nav-group">
        <div style="display: flex; flex-direction: column; align-items: center;">
            <div class="nav-group-label">Zoom</div>
            <div style="display: flex; gap: 5px;">
                <button class="nav-btn" data-action="zoom-in" title="Acercar">
                    <svg viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>
                </button>
                <button class="nav-btn" data-action="zoom-out" title="Alejar">
                    <svg viewBox="0 0 24 24"><path d="M19 13H5v-2h14v2z"/></svg>
                </button>
            </div>
        </div>
    </div>
    <div class="nav-group">
        <div style="display: flex; flex-direction: column; align-items: center;">
            <div class="nav-group-label">Mover</div>
            <div style="display: flex; gap: 5px;">
                <button class="nav-btn" data-action="pan-left" title="Mover Izquierda">
                    <svg viewBox="0 0 24 24"><path d="M15.41 16.59L10.83 12l4.58-4.59L14 6l-6 6 6 6z"/></svg>
                </button>
                <button class="nav-btn" data-action="pan-right" title="Mover Derecha">
                    <svg viewBox="0 0 24 24"><path d="M8.59 16.59L13.17 12 8.59 7.41 10 6l6 6-6 6z"/></svg>
                </button>
                <button class="nav-btn" data-action="pan-up" title="Mover Arriba">
                    <svg viewBox="0 0 24 24"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"/></svg>
                </button>
                <button class="nav-btn" data-action="pan-down" title="Mover Abajo">
                    <svg viewBox="0 0 24 24"><path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6z"/></svg>
                </button>
            </div>
        </div>
    </div>
    <div class="nav-group">
        <div style="display: flex; flex-direction: column; align-items: center;">
            <div class="nav-group-label">Reset</div>
            <div style="display: flex; gap: 5px;">
                <button class="nav-btn reset-btn" data-action="reset" title="Restablecer Vista">
                    <svg viewBox="0 0 24 24"><path d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z"/></svg>
                </button>
            </div>
        </div>
    </div>
</div>

<div id="legend">
    <b>üìã REFERENCIA T√âCNICA</b>
    <div class="legend-item">
        <span class="color-dot" style="background: #ff4d00; color: #ff4d00;"></span>
        <span>Infraestructura RIT (Troncal)</span>
    </div>
    <div class="legend-item">
        <span class="color-dot" style="background: #00b4d8; color: #00b4d8;"></span>
        <span>Red Lateral / Fibra √ìptica</span>
    </div>
    <div class="legend-item">
        <span class="color-dot" style="background: #6c757d; color: #6c757d;"></span>
        <span>C√°maras y Distribuci√≥n</span>
    </div>
    <div class="legend-item">
        <span class="color-dot" style="background: #ffc107; color: #ffc107;"></span>
        <span>Tomas de Usuario</span>
    </div>
    <div class="legend-item">
        <span class="color-dot" style="background: #28a745; color: #28a745;"></span>
        <span>Flujo de Datos (Animado)</span>
    </div>
</div>

<div id="tooltip"></div>

<div id="info-panel">
    <div class="info-number">1</div>
    <button class="info-close">√ó</button>
    <div class="info-title">T√≠tulo</div>
    <div class="info-desc">Descripci√≥n</div>
</div>

<div id="container"></div>

<script type="importmap">
{
    "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

const ritData = [
    { id: 1, name: "C√°mara de acceso", desc: "Ubicada en BNUP (Bien Nacional de Uso P√∫blico). Punto de entrada de los proveedores externos de telecomunicaciones al predio.", pos: [18, -1.5, 0], category: 'external', color: '#6c757d' },
    { id: 2, name: "Canalizaci√≥n externa", desc: "Tuber√≠a subterr√°nea que transporta los cables desde la calle hasta el l√≠mite del predio del condominio.", pos: [14, -1.5, 0], category: 'external', color: '#ff4d00' },
    { id: 3, name: "C√°mara de paso", desc: "Punto de registro y tiro al ingreso del condominio. Permite acceso para mantenimiento y empalmes.", pos: [8, -1.5, 0], category: 'external', color: '#6c757d' },
    { id: 4, name: "Canalizaci√≥n de enlace", desc: "Ducto principal que conecta la entrada externa con las salas t√©cnicas SOTI/SOTS del edificio.", pos: [4, -1.2, 0], category: 'trunk', color: '#ff4d00' },
    { id: 5, name: "Sala SOTI / SOTS", desc: "Salas de Operaciones de Telecomunicaciones. SOTI ubicada en s√≥tano, SOTS en azotea. Centro neur√°lgico de la RIT.", pos: [0, -1.05, 0], category: 'trunk', color: '#ff4d00' },
    { id: 6, name: "Canalizaci√≥n troncal", desc: "Shaft vertical que recorre todos los pisos del edificio. Es la columna vertebral de toda la RIT.", pos: [0, 8, 0], category: 'trunk', color: '#ff4d00' },
    { id: 7, name: "Cajas de distribuci√≥n (BUDI)", desc: "Building Distribution Box. Punto de derivaci√≥n en cada piso para conexi√≥n hacia los departamentos.", pos: [0.8, 7, 1.2], category: 'distribution', color: '#6c757d' },
    // CORREGIDO: Ajuste de posici√≥n de ID 8 para coincidir con el centro geom√©trico de la antena
    { id: 8, name: "Captaci√≥n de se√±al", desc: "Antenas satelitales y sistemas de recepci√≥n ubicados en la azotea del edificio.", pos: [0, 16, 0], category: 'trunk', color: '#ffffff' },
    { id: 9, name: "Canalizaci√≥n lateral", desc: "Tuber√≠a horizontal que va desde el shaft troncal hasta la CTR de cada departamento.", pos: [2.5, 7, 1], category: 'lateral', color: '#00b4d8' },
    { id: 10, name: "Caja Terminaci√≥n (CTR)", desc: "Caja terminal domiciliaria con 2 pelos de fibra √≥ptica. Se ubica generalmente sobre la puerta interior del departamento.", pos: [4.8, 7.5, 1], category: 'lateral', color: '#ffffff' },
    { id: 11, name: "Canalizaci√≥n interna", desc: "Ductos dentro de los muros del hogar que llevan la fibra hacia los distintos puntos de servicio.", pos: [6.15, 7, 2], category: 'internal', color: '#00b4d8' },
    { id: 12, name: "Tomas de usuario", desc: "Rosetas finales donde el usuario conecta sus equipos de TV, Internet y Telefon√≠a.", pos: [7.5, 6.5, 3], category: 'internal', color: '#ffc107' }
];

// --- SCENE SETUP (DAY MODE) ---
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xf0f2f5);
scene.fog = new THREE.Fog(0xf0f2f5, 30, 90);

const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.0;
document.getElementById('container').appendChild(renderer.domElement);

// CSS2D Renderer for labels
const labelRenderer = new CSS2DRenderer();
labelRenderer.setSize(window.innerWidth, window.innerHeight);
labelRenderer.domElement.style.position = 'absolute';
labelRenderer.domElement.style.top = '0';
labelRenderer.domElement.style.pointerEvents = 'none';
document.getElementById('container').appendChild(labelRenderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
camera.position.set(35, 20, 35);
controls.target.set(0, 6, 0);
controls.enableDamping = true;
controls.dampingFactor = 0.05;
controls.maxPolarAngle = Math.PI * 0.85;
controls.minDistance = 10;
controls.maxDistance = 60;

// --- LIGHTING (DAY MODE) ---
const ambient = new THREE.AmbientLight(0xffffff, 0.7);
scene.add(ambient);

const sun = new THREE.DirectionalLight(0xffffee, 1.8);
sun.position.set(20, 50, 20);
sun.castShadow = true;
sun.shadow.mapSize.width = 2048;
sun.shadow.mapSize.height = 2048;
sun.shadow.bias = -0.0001;
sun.shadow.camera.near = 1;
sun.shadow.camera.far = 100;
sun.shadow.camera.left = -40;
sun.shadow.camera.right = 40;
sun.shadow.camera.top = 40;
sun.shadow.camera.bottom = -40;
scene.add(sun);

const fillLight = new THREE.DirectionalLight(0xddeeff, 0.5);
fillLight.position.set(-10, 10, -10);
scene.add(fillLight);

// --- MATERIALS (DAY MODE) ---
const materials = {
    glass: new THREE.MeshPhysicalMaterial({
        color: 0x88ccff,
        transparent: true,
        opacity: 0.4,
        roughness: 0.05,
        metalness: 0.2,
        transmission: 0.6,
        thickness: 0.5,
        clearcoat: 1.0
    }),
    concrete: new THREE.MeshStandardMaterial({
        color: 0xf8f9fa,
        roughness: 0.6,
        metalness: 0.1
    }),
    floor: new THREE.MeshStandardMaterial({
        color: 0xe9ecef,
        roughness: 0.8,
        metalness: 0.1
    }),
    ground: new THREE.MeshStandardMaterial({
        color: 0xe3e6e8,
        roughness: 1,
        metalness: 0
    }),
    street: new THREE.MeshStandardMaterial({
        color: 0x343a40,
        roughness: 0.8,
        metalness: 0
    }),
    wall: new THREE.MeshStandardMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.2,
        roughness: 0.8,
        side: THREE.DoubleSide
    })
};

// --- GROUND AND ENVIRONMENT ---
const groundGroup = new THREE.Group();

const groundGeo = new THREE.PlaneGeometry(100, 100);
const ground = new THREE.Mesh(groundGeo, materials.ground);
ground.rotation.x = -Math.PI / 2;
ground.position.y = -2;
ground.receiveShadow = true;
groundGroup.add(ground);

const streetGeo = new THREE.PlaneGeometry(8, 100);
const street = new THREE.Mesh(streetGeo, materials.street);
street.rotation.x = -Math.PI / 2;
street.position.set(22, -1.95, 0);
street.receiveShadow = true;
groundGroup.add(street);

const lineGeo = new THREE.PlaneGeometry(0.2, 3);
const lineMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
for (let i = -40; i < 40; i += 8) {
    const line = new THREE.Mesh(lineGeo, lineMat);
    line.rotation.x = -Math.PI / 2;
    line.position.set(22, -1.9, i);
    groundGroup.add(line);
}

const gridHelper = new THREE.GridHelper(100, 50, 0xadb5bd, 0xcfd4da);
gridHelper.position.y = -1.99;
groundGroup.add(gridHelper);

const boundaryGeo = new THREE.PlaneGeometry(0.15, 60);
const boundaryMat = new THREE.MeshBasicMaterial({ color: 0xff4d00, transparent: true, opacity: 0.7 });
const boundary = new THREE.Mesh(boundaryGeo, boundaryMat);
boundary.rotation.x = -Math.PI / 2;
boundary.position.set(10, -1.9, 0);
groundGroup.add(boundary);

scene.add(groundGroup);

// --- BUILDING ---
const buildingGroup = new THREE.Group();
const FLOORS = 5;
const FLOOR_HEIGHT = 3;
const BUILDING_WIDTH = 16; 
const BUILDING_DEPTH = 10;

for (let i = 0; i < FLOORS; i++) {
    const slabGeo = new THREE.BoxGeometry(BUILDING_WIDTH, 0.3, BUILDING_DEPTH);
    const slab = new THREE.Mesh(slabGeo, materials.floor);
    slab.position.y = i * FLOOR_HEIGHT;
    slab.castShadow = true;
    slab.receiveShadow = true;
    buildingGroup.add(slab);

    const columnGeo = new THREE.BoxGeometry(0.5, FLOOR_HEIGHT - 0.3, 0.5);
    const columnPositions = [
        [-BUILDING_WIDTH/2 + 0.5, BUILDING_DEPTH/2 - 0.5],
        [BUILDING_WIDTH/2 - 0.5, BUILDING_DEPTH/2 - 0.5],
        [-BUILDING_WIDTH/2 + 0.5, -BUILDING_DEPTH/2 + 0.5],
        [BUILDING_WIDTH/2 - 0.5, -BUILDING_DEPTH/2 + 0.5],
        [0, BUILDING_DEPTH/2 - 0.5],
        [0, -BUILDING_DEPTH/2 + 0.5]
    ];
    
    columnPositions.forEach(([x, z]) => {
        const column = new THREE.Mesh(columnGeo, materials.concrete);
        column.position.set(x, i * FLOOR_HEIGHT + FLOOR_HEIGHT/2, z);
        column.castShadow = true;
        buildingGroup.add(column);
    });

    if (i > 0) {
        for (let w = 0; w < 4; w++) {
            const windowGeo = new THREE.PlaneGeometry(2, 2);
            const windowMesh = new THREE.Mesh(windowGeo, materials.glass);
            windowMesh.position.set(-4.5 + w * 3, i * FLOOR_HEIGHT + 1.5, BUILDING_DEPTH/2 + 0.01);
            buildingGroup.add(windowMesh);
        }
        for (let w = 0; w < 4; w++) {
            const windowMesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), materials.glass);
            windowMesh.position.set(-4.5 + w * 3, i * FLOOR_HEIGHT + 1.5, -BUILDING_DEPTH/2 - 0.01);
            windowMesh.rotation.y = Math.PI;
            buildingGroup.add(windowMesh);
        }
    }
}

const roofGeo = new THREE.BoxGeometry(BUILDING_WIDTH + 1, 0.5, BUILDING_DEPTH + 1);
const roof = new THREE.Mesh(roofGeo, materials.concrete);
roof.position.y = FLOORS * FLOOR_HEIGHT + 0.25;
roof.castShadow = true;
buildingGroup.add(roof);

const basementGeo = new THREE.BoxGeometry(BUILDING_WIDTH - 0.5, 2, BUILDING_DEPTH - 0.5);
const basementMat = new THREE.MeshStandardMaterial({ 
    color: 0x495057, 
    transparent: true, 
    opacity: 0.3,
    roughness: 0.8 
});
const basement = new THREE.Mesh(basementGeo, basementMat);
basement.position.y = -1;
buildingGroup.add(basement);

scene.add(buildingGroup);

// --- RIT ELEMENTS ---
const meshMap = {};
const labelMap = {};
const glowMeshes = [];
let showLabels = false;

// Create CSS2D label
function createLabel(id, name, position) {
    const div = document.createElement('div');
    div.style.cssText = `
        background: linear-gradient(135deg, rgba(255, 77, 0, 0.95), rgba(255, 100, 0, 0.9));
        color: white;
        padding: 6px 12px;
        border-radius: 6px;
        font-size: 12px;
        font-weight: 500;
        font-family: 'Roboto', sans-serif;
        white-space: nowrap;
        box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        border: 1px solid rgba(255,255,255,0.2);
        display: none;
    `;
    div.innerHTML = `<span style="font-weight:700; margin-right:5px;">${id}</span>${name}`;
    
    const label = new CSS2DObject(div);
    label.position.set(position[0], position[1] + 2, position[2]);
    label.visible = false;
    
    return label;
}

// --- FIBER CABLE FUNCTION (Returns Curve) ---
function createFiberCable(points, color = 0x00b4d8) {
    const curve = new THREE.CatmullRomCurve3(points);
    const geometry = new THREE.TubeGeometry(curve, 64, 0.04, 8, false);
    const material = new THREE.MeshStandardMaterial({
        color: color,
        roughness: 0.3,
        metalness: 0.5
    });
    return { mesh: new THREE.Mesh(geometry, material), curve: curve };
}

// 1. C√°mara de acceso
const camGeo = new THREE.BoxGeometry(1.8, 1.4, 1.8);
const camMat = new THREE.MeshStandardMaterial({ color: 0x6c757d, roughness: 0.6, metalness: 0.4 });
meshMap[1] = new THREE.Mesh(camGeo, camMat);
meshMap[1].position.set(18, -1.3, 0);
meshMap[1].castShadow = true;
scene.add(meshMap[1]);

const lidGeo = new THREE.BoxGeometry(2, 0.15, 2);
const lidMat = new THREE.MeshStandardMaterial({ color: 0x495057, roughness: 0.5, metalness: 0.6 });
const lid1 = new THREE.Mesh(lidGeo, lidMat);
lid1.position.set(18, -0.55, 0);
scene.add(lid1);

// 2. Canalizaci√≥n externa
const pipeGeo2 = new THREE.CylinderGeometry(0.2, 0.2, 8, 16);
pipeGeo2.rotateZ(Math.PI / 2);
const pipeMat = new THREE.MeshStandardMaterial({ color: 0xff4d00, roughness: 0.3, metalness: 0.3, emissive: 0xff4d00, emissiveIntensity: 0.1 });
meshMap[2] = new THREE.Mesh(pipeGeo2, pipeMat.clone());
meshMap[2].position.set(14, -1.5, 0);
scene.add(meshMap[2]);

// 3. C√°mara de paso
meshMap[3] = new THREE.Mesh(camGeo.clone(), camMat.clone());
meshMap[3].position.set(8, -1.3, 0);
meshMap[3].castShadow = true;
scene.add(meshMap[3]);

const lid2 = lid1.clone();
lid2.position.set(8, -0.55, 0);
scene.add(lid2);

// 4. Canalizaci√≥n de enlace
const pipeGeo4 = new THREE.CylinderGeometry(0.2, 0.2, 8, 16);
pipeGeo4.rotateZ(Math.PI / 2);
meshMap[4] = new THREE.Mesh(pipeGeo4, pipeMat.clone());
meshMap[4].position.set(4, -1.2, 0);
scene.add(meshMap[4]);

// 5. Sala SOTI
const sotiGeo = new THREE.BoxGeometry(3.5, 1.9, 3);
const sotiMat = new THREE.MeshStandardMaterial({ color: 0xff4d00, roughness: 0.4, metalness: 0.5, emissive: 0xff4d00, emissiveIntensity: 0.1 });
meshMap[5] = new THREE.Mesh(sotiGeo, sotiMat);
meshMap[5].position.set(0, -1.05, 0); 
meshMap[5].castShadow = true;
buildingGroup.add(meshMap[5]);

// SOTI door
const doorGeo = new THREE.PlaneGeometry(1.2, 1.5);
const doorMat = new THREE.MeshStandardMaterial({ color: 0x343a40 });
const sotiDoor = new THREE.Mesh(doorGeo, doorMat);
sotiDoor.position.set(0, -1.2, 1.51);
buildingGroup.add(sotiDoor);

// SOTS
const sotsGeo = new THREE.BoxGeometry(3, 2.2, 2.5);
const sots = new THREE.Mesh(sotsGeo, sotiMat.clone());
sots.position.set(0, FLOORS * FLOOR_HEIGHT + 1.6, 0);
sots.castShadow = true;
buildingGroup.add(sots);

// 6. Canalizaci√≥n troncal (Shaft)
const shaftGeo = new THREE.CylinderGeometry(0.5, 0.5, FLOORS * FLOOR_HEIGHT - 2, 16);
const shaftMat = new THREE.MeshStandardMaterial({ color: 0xff4d00, roughness: 0.3, metalness: 0.4, emissive: 0xff4d00, emissiveIntensity: 0.1 });
meshMap[6] = new THREE.Mesh(shaftGeo, shaftMat);
meshMap[6].position.set(0, FLOORS * FLOOR_HEIGHT / 2 + 1, 0);
buildingGroup.add(meshMap[6]);

// --- ELEMENTOS DE DISTRIBUCI√ìN ---
const budiGeo = new THREE.BoxGeometry(1, 1.2, 0.6);
const budiMat = new THREE.MeshStandardMaterial({ color: 0x6c757d, roughness: 0.5, metalness: 0.5 });
const lateralGeo = new THREE.CylinderGeometry(0.12, 0.12, 3.5, 8); 
lateralGeo.rotateZ(Math.PI / 2);
const lateralMat = new THREE.MeshStandardMaterial({ color: 0x00b4d8, roughness: 0.3, metalness: 0.4, emissive: 0x00b4d8, emissiveIntensity: 0.1 });
const ctrGeo = new THREE.BoxGeometry(0.6, 0.7, 0.18);
const ctrMat = new THREE.MeshStandardMaterial({ color: 0xf0f0f0, roughness: 0.3, metalness: 0.1 });
const tomaGeo = new THREE.BoxGeometry(0.3, 0.4, 0.1);
const tomaMat = new THREE.MeshStandardMaterial({ color: 0xffc107, roughness: 0.3, metalness: 0.5 });
const internalWallGeo = new THREE.BoxGeometry(0.1, FLOOR_HEIGHT - 0.2, 4);
const internalGeo = new THREE.CylinderGeometry(0.08, 0.08, 2.7, 8);
internalGeo.rotateZ(Math.PI / 2);

// Store lateral curves for particle logic
const pathMap = { main: null, vertical: null, lateral: null };

for (let i = 0; i < FLOORS; i++) {
    // 7. BUDI
    const budi = new THREE.Mesh(budiGeo, budiMat.clone());
    budi.position.set(0.8, i * FLOOR_HEIGHT + 1, 1);
    budi.castShadow = true;
    buildingGroup.add(budi);
    
    // Etiqueta BUDI
    const labelGeo = new THREE.PlaneGeometry(0.6, 0.3);
    const labelMat = new THREE.MeshBasicMaterial({ color: 0x00b4d8 });
    const label = new THREE.Mesh(labelGeo, labelMat);
    label.position.set(0.8, i * FLOOR_HEIGHT + 1.3, 1.31);
    buildingGroup.add(label);
    
    if (i === 1) meshMap[7] = budi;

    // 9. Canalizaci√≥n Lateral (Tuber√≠a Azul)
    const lateral = new THREE.Mesh(lateralGeo.clone(), lateralMat.clone());
    lateral.position.set(2.8, i * FLOOR_HEIGHT + 1.2, 1);
    buildingGroup.add(lateral);
    if (i === 1) meshMap[9] = lateral;

    // Cableado Fibra √ìptica Horizontal
    const floorFiber = createFiberCable([
        new THREE.Vector3(0.9, i * FLOOR_HEIGHT + 1.2, 1), 
        new THREE.Vector3(2.8, i * FLOOR_HEIGHT + 1.2, 1), 
        new THREE.Vector3(4.7, i * FLOOR_HEIGHT + 1.2, 1), 
        new THREE.Vector3(4.9, i * FLOOR_HEIGHT + 1.2, 1), 
        new THREE.Vector3(5.3, i * FLOOR_HEIGHT + 1.2, 1.8), 
        new THREE.Vector3(6.3, i * FLOOR_HEIGHT + 1.2, 2), 
        new THREE.Vector3(7.8, i * FLOOR_HEIGHT + 1.2, 2)  
    ], 0x00b4d8);
    buildingGroup.add(floorFiber.mesh);
    
    // Save the curve of the second floor as the "representative" lateral path
    if (i === 1) pathMap.lateral = floorFiber.curve;

    // 10. CTR
    const ctr = new THREE.Mesh(ctrGeo.clone(), ctrMat.clone());
    ctr.position.set(4.8, i * FLOOR_HEIGHT + 1.2, 1); 
    ctr.castShadow = true;
    buildingGroup.add(ctr);
    
    // Luz indicador CTR
    const lightGeo = new THREE.CircleGeometry(0.08, 16);
    const lightMat = new THREE.MeshBasicMaterial({ color: 0x00cc00 });
    const light = new THREE.Mesh(lightGeo, lightMat);
    light.position.set(4.8, i * FLOOR_HEIGHT + 1.4, 1.1);
    buildingGroup.add(light);
    if (i === 1) meshMap[10] = ctr;

    // 11. Canalizaci√≥n Interna
    const internal = new THREE.Mesh(internalGeo.clone(), lateralMat.clone());
    internal.position.set(6.3, i * FLOOR_HEIGHT + 1.2, 2); 
    buildingGroup.add(internal);
    if (i === 1) meshMap[11] = internal;

    // 12. Tomas de Usuario
    const toma = new THREE.Mesh(tomaGeo, tomaMat.clone());
    toma.position.set(7.8, i * FLOOR_HEIGHT + 1.2, 2);
    toma.castShadow = true;
    buildingGroup.add(toma);
    
    const toma2 = new THREE.Mesh(tomaGeo.clone(), tomaMat.clone());
    toma2.position.set(7.8, i * FLOOR_HEIGHT + 1.2, 3); 
    buildingGroup.add(toma2);
    
    if (i === 2) meshMap[12] = toma;

    // Muro divisorio ficticio
    const wall = new THREE.Mesh(internalWallGeo, materials.wall);
    wall.position.set(4.85, i * FLOOR_HEIGHT + FLOOR_HEIGHT/2, 0);
    buildingGroup.add(wall);
}

// 8. Antenas (CORREGIDO)
const antennaGroup = new THREE.Group();
const dishGeo = new THREE.SphereGeometry(1.2, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
const dishMat = new THREE.MeshStandardMaterial({ color: 0xffffff, side: THREE.DoubleSide, metalness: 0.8, roughness: 0.2 });
const dish = new THREE.Mesh(dishGeo, dishMat);
dish.rotation.x = Math.PI - 0.5; 
dish.position.set(-2, 1.0, 0);
antennaGroup.add(dish);

const armGeo = new THREE.CylinderGeometry(0.08, 0.08, 1.8);
const armMat = new THREE.MeshStandardMaterial({ color: 0x666666 });
const arm = new THREE.Mesh(armGeo, armMat);
arm.rotation.x = Math.PI - 0.5;
arm.position.set(-2, 1.5, 0.5);
antennaGroup.add(arm);

const antGeo = new THREE.CylinderGeometry(0.08, 0.12, 2.5);
const ant = new THREE.Mesh(antGeo, new THREE.MeshStandardMaterial({ color: 0xaaaabb, metalness: 0.9 }));
ant.position.set(2, 1.25, 0);
antennaGroup.add(ant);

const topGeo = new THREE.SphereGeometry(0.2);
const topMat = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 0.8 });
const top = new THREE.Mesh(topGeo, topMat);
top.position.set(2, 2.6, 0);
antennaGroup.add(top);
glowMeshes.push({ mesh: top, baseIntensity: 0.8 });

antennaGroup.position.set(0, FLOORS * FLOOR_HEIGHT + 0.5, 0);
meshMap[8] = antennaGroup;
buildingGroup.add(antennaGroup);

// --- CREATE MARKERS AND LABELS ---
ritData.forEach(item => {
    const label = createLabel(item.id, item.name, item.pos);
    labelMap[item.id] = label;
    scene.add(label);
});

// --- DATA FLOW PARTICLES (SMART SYSTEM) ---
const particleCount = 100;
const particleGeometry = new THREE.BufferGeometry();
const particlePositions = new Float32Array(particleCount * 3);
const particleColors = new Float32Array(particleCount * 3);
const particleProgress = new Float32Array(particleCount);
const particleSpeeds = [];

let activeCurve = null; 

for (let i = 0; i < particleCount; i++) {
    particlePositions[i * 3] = 0;
    particlePositions[i * 3 + 1] = -100; 
    particlePositions[i * 3 + 2] = 0;
    
    particleColors[i * 3] = 0.0;
    particleColors[i * 3 + 1] = 0.8 + Math.random() * 0.2;
    particleColors[i * 3 + 2] = 0.2;
    
    particleProgress[i] = Math.random();
    particleSpeeds.push(0.002 + Math.random() * 0.003);
}

particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
particleGeometry.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));

const particleMaterial = new THREE.PointsMaterial({
    size: 0.25,
    vertexColors: true,
    transparent: true,
    opacity: 0.0, 
    blending: THREE.AdditiveBlending 
});

const particles = new THREE.Points(particleGeometry, particleMaterial);
scene.add(particles);

// --- CABLES DE FIBRA PRINCIPALES & CURVES ---

const mainFiber = createFiberCable([
    new THREE.Vector3(18, -1.5, 0),
    new THREE.Vector3(8, -1.5, 0),
    new THREE.Vector3(7, -1.3, 0),
    new THREE.Vector3(4, -1.2, 0),
    new THREE.Vector3(0, -1.2, 0),
    new THREE.Vector3(0, -1.05, 0)
], 0xff4d00);
scene.add(mainFiber.mesh);
pathMap.main = mainFiber.curve;

const verticalFiber = createFiberCable([
    new THREE.Vector3(0, -1.05, 0),
    new THREE.Vector3(0, 5, 0),
    new THREE.Vector3(0, 8, 0),
    new THREE.Vector3(0, 11, 0),
    new THREE.Vector3(0, 14, 0)
], 0xff4d00);
buildingGroup.add(verticalFiber.mesh);
pathMap.vertical = verticalFiber.curve;

// --- UI INTERACTION ---
const menu = document.getElementById('menu-items');
const tooltip = document.getElementById('tooltip');
const infoPanel = document.getElementById('info-panel');

ritData.forEach(item => {
    const div = document.createElement('div');
    div.className = 'rit-item';
    div.dataset.id = item.id;
    div.innerHTML = `
        <div class="number-badge">${item.id}</div>
        <div class="text-content">
            <b>${item.name}</b>
            <span>${item.desc.substring(0, 60)}...</span>
        </div>
        <svg class="item-icon" viewBox="0 0 24 24" fill="none" stroke="#ff4d00" stroke-width="2">
            <path d="M9 18l6-6-6-6"/>
        </svg>
    `;
    div.onclick = () => focusItem(item.id, item.pos, div);
    menu.appendChild(div);
});

let activeItem = null;
let savedMaterialsState = []; // Stores { mesh, originalEmissiveColor, originalEmissiveIntensity }

// Helper to get all meshes from an object (including children)
function getMeshes(object) {
    const meshes = [];
    if (object.isMesh) {
        meshes.push(object);
    }
    if (object.isGroup) {
        object.traverse((child) => {
            if (child.isMesh) {
                meshes.push(child);
            }
        });
    }
    return meshes;
}

function restoreOriginalState() {
    if (savedMaterialsState.length > 0) {
        savedMaterialsState.forEach(state => {
            if (state.mesh.material) {
                state.mesh.material.emissive.setHex(state.originalEmissiveColor);
                state.mesh.material.emissiveIntensity = state.originalEmissiveIntensity;
            }
        });
        savedMaterialsState = [];
    }
}

function focusItem(id, pos, element) {
    document.querySelectorAll('.rit-item').forEach(el => el.classList.remove('active'));
    if (element) element.classList.add('active');

    // 1. Restore previous selection
    restoreOriginalState();

    activeItem = id;
    
    // 2. Highlight new selection (Save state & Set White)
    if (meshMap[id]) {
        const meshesToHighlight = getMeshes(meshMap[id]);
        
        meshesToHighlight.forEach(mesh => {
            if (mesh.material) {
                // Save state
                savedMaterialsState.push({
                    mesh: mesh,
                    originalEmissiveColor: mesh.material.emissive.getHex(),
                    originalEmissiveIntensity: mesh.material.emissiveIntensity
                });
                
                // Set highlight
                mesh.material.emissive.setHex(0xffffff);
            }
        });
    }

    // 3. Particle Logic
    if (id >= 1 && id <= 4) {
        activeCurve = pathMap.main;
        particles.material.opacity = 1.0;
        particles.parent = scene; 
    } else if (id === 5 || id === 6 || id === 8) {
        activeCurve = pathMap.vertical;
        particles.material.opacity = 1.0;
        particles.parent = buildingGroup;
    } else if (id >= 7) {
        activeCurve = pathMap.lateral;
        particles.material.opacity = 1.0;
        particles.parent = buildingGroup;
    } else {
        activeCurve = null;
        particles.material.opacity = 0.0;
    }

    // 4. Info Panel
    const item = ritData.find(r => r.id === id);
    if (item) {
        infoPanel.querySelector('.info-number').textContent = id;
        infoPanel.querySelector('.info-title').textContent = item.name;
        infoPanel.querySelector('.info-desc').textContent = item.desc;
        infoPanel.classList.add('visible');
    }

    // 5. Camera Logic
    const targetPos = new THREE.Vector3(pos[0], pos[1], pos[2]);
    let offset;
    
    // ID 8 (Antena) special offset to view from distance
    if (id === 8) {
        offset = new THREE.Vector3(10, 2, 10);
    } else if (id >= 7) { 
        offset = new THREE.Vector3(6, 0, 6);
    } else { 
        offset = new THREE.Vector3(12, 0, 12);
    }
    
    const newCamPos = targetPos.clone().add(offset);
    animateCamera(newCamPos, targetPos);
}

function animateCamera(newCamPos, newTarget) {
    let progress = 0;
    const duration = 60;
    const startPos = camera.position.clone();
    const startTarget = controls.target.clone();

    function animate() {
        progress++;
        const t = easeOutCubic(progress / duration);
        
        camera.position.lerpVectors(startPos, newCamPos, t);
        controls.target.lerpVectors(startTarget, newTarget, t);
        
        if (progress < duration) {
            requestAnimationFrame(animate);
        }
    }
    animate();
}

function easeOutCubic(t) {
    return 1 - Math.pow(1 - t, 3);
}

infoPanel.querySelector('.info-close').onclick = () => {
    infoPanel.classList.remove('visible');
};

const resetBtn = document.querySelector('.nav-btn[data-action="reset"]');
resetBtn.addEventListener('click', () => {
    restoreOriginalState();
    activeItem = null;
    activeCurve = null;
    particles.material.opacity = 0.0;
    document.querySelectorAll('.rit-item').forEach(el => el.classList.remove('active'));
    infoPanel.classList.remove('visible');
});

const toggleLabelsBtn = document.getElementById('toggle-labels');
toggleLabelsBtn.onclick = () => {
    showLabels = !showLabels;
    toggleLabelsBtn.classList.toggle('active', showLabels);
    toggleLabelsBtn.innerHTML = showLabels ? 
        `<svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg> Ocultar Etiquetas` :
        `<svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2"><path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"/><line x1="1" y1="1" x2="23" y2="23"/></svg> Mostrar Etiquetas`;
    
    Object.values(labelMap).forEach(label => {
        label.visible = showLabels;
        label.element.style.display = showLabels ? 'block' : 'none';
    });
};

const navSpeed = 0.1;
const zoomSpeed = 2;
const panSpeed = 0.5;

document.querySelectorAll('.nav-btn').forEach(btn => {
    let intervalId = null;
    
    const action = btn.dataset.action;
    
    const executeAction = () => {
        const spherical = new THREE.Spherical();
        spherical.setFromVector3(camera.position.clone().sub(controls.target));
        
        switch(action) {
            case 'rotate-left':
                spherical.theta -= navSpeed;
                camera.position.copy(controls.target).add(new THREE.Vector3().setFromSpherical(spherical));
                break;
            case 'rotate-right':
                spherical.theta += navSpeed;
                camera.position.copy(controls.target).add(new THREE.Vector3().setFromSpherical(spherical));
                break;
            case 'rotate-up':
                spherical.phi = Math.max(0.1, spherical.phi - navSpeed);
                camera.position.copy(controls.target).add(new THREE.Vector3().setFromSpherical(spherical));
                break;
            case 'rotate-down':
                spherical.phi = Math.min(Math.PI - 0.1, spherical.phi + navSpeed);
                camera.position.copy(controls.target).add(new THREE.Vector3().setFromSpherical(spherical));
                break;
            case 'zoom-in':
                camera.position.lerp(controls.target, 0.1);
                break;
            case 'zoom-out':
                const dir = camera.position.clone().sub(controls.target).normalize();
                camera.position.add(dir.multiplyScalar(zoomSpeed));
                break;
            case 'pan-left':
                const left = new THREE.Vector3(-panSpeed, 0, 0).applyQuaternion(camera.quaternion);
                camera.position.add(left);
                controls.target.add(left);
                break;
            case 'pan-right':
                const right = new THREE.Vector3(panSpeed, 0, 0).applyQuaternion(camera.quaternion);
                camera.position.add(right);
                controls.target.add(right);
                break;
            case 'pan-up':
                const up = new THREE.Vector3(0, panSpeed, 0);
                camera.position.add(up);
                controls.target.add(up);
                break;
            case 'pan-down':
                const down = new THREE.Vector3(0, -panSpeed, 0);
                camera.position.add(down);
                controls.target.add(down);
                break;
            case 'reset':
                animateCamera(new THREE.Vector3(35, 20, 35), new THREE.Vector3(0, 6, 0));
                restoreOriginalState();
                activeItem = null;
                activeCurve = null; 
                particles.material.opacity = 0.0;
                document.querySelectorAll('.rit-item').forEach(el => el.classList.remove('active'));
                infoPanel.classList.remove('visible');
                break;
        }
    };
    
    btn.onmousedown = () => {
        executeAction();
        intervalId = setInterval(executeAction, 50);
    };
    
    btn.onmouseup = () => clearInterval(intervalId);
    btn.onmouseleave = () => clearInterval(intervalId);
    btn.onclick = executeAction;
});

document.querySelectorAll('.preset-btn').forEach(btn => {
    btn.onclick = () => {
        const view = btn.dataset.view;
        let newPos, newTarget;
        
        switch(view) {
            case 'front':
                newPos = new THREE.Vector3(0, 8, 40);
                newTarget = new THREE.Vector3(0, 8, 0);
                break;
            case 'side':
                newPos = new THREE.Vector3(40, 8, 0);
                newTarget = new THREE.Vector3(0, 8, 0);
                break;
            case 'top':
                newPos = new THREE.Vector3(0, 45, 0.1);
                newTarget = new THREE.Vector3(0, 0, 0);
                break;
            case 'iso':
                newPos = new THREE.Vector3(35, 20, 35);
                newTarget = new THREE.Vector3(0, 6, 0);
                break;
        }
        
        animateCamera(newPos, newTarget);
    };
});

const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

function onMouseMove(event) {
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    
    raycaster.setFromCamera(mouse, camera);
    const meshes = Object.values(meshMap).filter(m => m);
    const intersects = raycaster.intersectObjects(meshes, true);
    
    if (intersects.length > 0) {
        const obj = intersects[0].object;
        let foundId = null;
        
        for (const [id, mesh] of Object.entries(meshMap)) {
            if (mesh === obj || (mesh.children && mesh.children.includes(obj))) {
                foundId = id;
                break;
            }
        }
        
        if (foundId) {
            const item = ritData.find(r => r.id == foundId);
            if (item) {
                tooltip.textContent = item.name;
                tooltip.style.left = event.clientX + 15 + 'px';
                tooltip.style.top = event.clientY + 15 + 'px';
                tooltip.classList.add('visible');
                document.body.style.cursor = 'pointer';
            }
        }
    } else {
        tooltip.classList.remove('visible');
        document.body.style.cursor = 'default';
    }
}

function onClick(event) {
    if (event.target.closest('#side-panel') || event.target.closest('#legend') || 
        event.target.closest('#nav-controls') || event.target.closest('#view-presets') ||
        event.target.closest('#toggle-labels') || event.target.closest('#info-panel')) return;
    
    raycaster.setFromCamera(mouse, camera);
    const meshes = Object.values(meshMap).filter(m => m);
    const intersects = raycaster.intersectObjects(meshes, true);
    
    if (intersects.length > 0) {
        const obj = intersects[0].object;
        let foundId = null;
        
        for (const [id, mesh] of Object.entries(meshMap)) {
            if (mesh === obj || (mesh.children && mesh.children.includes(obj))) {
                foundId = id;
                break;
            }
        }
        
        if (foundId) {
            const item = ritData.find(r => r.id == foundId);
            const element = document.querySelector(`.rit-item[data-id="${foundId}"]`);
            if (item && element) {
                focusItem(parseInt(foundId), item.pos, element);
                element.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }
    }
}

window.addEventListener('mousemove', onMouseMove);
window.addEventListener('click', onClick);

let time = 0;

function animate() {
    requestAnimationFrame(animate);
    time += 0.016;
    
    // --- SMART PARTICLE ANIMATION ---
    if (activeCurve) {
        const positions = particles.geometry.attributes.position.array;
        
        for (let i = 0; i < particleCount; i++) {
            // Update progress
            particleProgress[i] += particleSpeeds[i];
            if (particleProgress[i] > 1) particleProgress[i] = 0;
            
            // Get point along the active curve
            const point = activeCurve.getPoint(particleProgress[i]);
            
            positions[i * 3] = point.x;
            positions[i * 3 + 1] = point.y;
            positions[i * 3 + 2] = point.z;
        }
        particles.geometry.attributes.position.needsUpdate = true;
    }
    
    // --- PULSE ANIMATION (FOR GROUPS AND MESHES) ---
    if (activeItem && savedMaterialsState.length > 0) {
        // Base 1.0, amplitude 0.5 -> Range 0.5 to 1.5
        const pulse = 1.0 + Math.sin(time * 8) * 0.5;
        savedMaterialsState.forEach(state => {
            if (state.mesh.material) {
                state.mesh.material.emissiveIntensity = pulse;
            }
        });
    }
    
    // Animate glow meshes (Antenna light)
    glowMeshes.forEach((item, i) => {
        if (item.mesh && item.mesh.material) {
            item.mesh.material.emissiveIntensity = item.baseIntensity + Math.sin(time * 4) * 0.3;
        }
    });
    
    controls.update();
    renderer.render(scene, camera);
    labelRenderer.render(scene, camera);
}

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    labelRenderer.setSize(window.innerWidth, window.innerHeight);
});

setTimeout(() => {
    document.getElementById('loading').classList.add('hidden');
}, 1500);

animate();
</script>
</body>
</html>